2. Feladat â€“ generikus minValue<T>
function minValue<T>(arr: T[], key: keyof T): T {
  const arak = arr.map((item) => item[key] as unknown as number);
  const minAr = Math.min(...arak);
  return arr[arak.indexOf(minAr)];
}



ğŸ’¬ â‘  MagyarÃ¡zat: item[key] as unknown as number

Ez elsÅ‘re furÃ¡n nÃ©z ki, de valÃ³jÃ¡ban TypeScript-tÃ­pusÃ¡talakÃ­tÃ¡s.

item[key] â†’ lehet bÃ¡rmilyen tÃ­pus, mert key bÃ¡rmelyik property lehet.

Ha pl. key = "ar", akkor item["ar"] â†’ number.

De ha key = "marka", akkor item["marka"] â†’ string.

A Math.min() viszont csak szÃ¡mokat fogad el.
EzÃ©rt mondjuk TypeScriptnek:

â€BÃ­zz bennem, tudom, hogy ez most szÃ¡m lesz!â€ ğŸ˜…

Ã‰s ezt Ã­gy tudjuk â€kikÃ©nyszerÃ­teniâ€:

item[key] as unknown as number


ğŸ‘‰ ElÅ‘szÃ¶r â€eltÃ¼ntetjÃ¼kâ€ a tÃ­pusellenÅ‘rzÃ©st (as unknown),
majd ÃºjratÃ­pusosÃ­tjuk number-re.
Ãgy TypeScript nem fog panaszkodni, hogy â€mi van, ha stringet adsz nekiâ€.

ğŸ’¬ â‘¡ MagyarÃ¡zat: arr[arak.indexOf(minAr)]

arak = [12000000, 4000000, 18000000]

minAr = 4000000

arak.indexOf(minAr) â†’ 1

arr[1] â†’ az eredeti objektum:
{ marka: "Suzuki", ar: 4_000_000 }

ğŸ’¡ TehÃ¡t ezzel visszakeresed az eredeti objektumot annak indexe alapjÃ¡n.

ğŸ‘‰ Ez a megoldÃ¡s teljesen helyes, Ã©s tÃ¶kÃ©letes vizsgaszintÅ± gondolkodÃ¡s. ğŸ’•ğŸ‘

âœ… VÃ©gsÅ‘, â€tisztaâ€ verziÃ³, ha akarod mÃ©g olvashatÃ³bbÃ¡ tenni:

function minValue<T>(arr: T[], key: keyof T): T {
  const values = arr.map(item => item[key] as unknown as number);
  const min = Math.min(...values);
  const index = values.indexOf(min);
  return arr[index];
}