function szamgyakorisag(input: number | number[]): Record<number, number> {
  const eredm: Record<number, number> = {};
  
  // 1ï¸âƒ£ Ha szÃ¡mot kap, alakÃ­tjuk stringgÃ©, hogy karakterenkÃ©nt bejÃ¡rhassuk
  const tomb: number[] = 
    typeof input === "number"
      ? input.toString().split("").map(Number)
      : input; // ha mÃ¡r eleve tÃ¶mb, nem alakÃ­tjuk Ã¡t
  
  // 2ï¸âƒ£ VÃ©gigmegyÃ¼nk az elemek kÃ¶zÃ¶tt, Ã©s szÃ¡moljuk, hÃ¡nyszor fordulnak elÅ‘
  for (const szam of tomb) {
    eredm[szam] = (eredm[szam] || 0) + 1;
  }

  return eredm;
}

// ğŸ”¹ Tesztesetek
console.log(szamgyakorisag(12344));        // âœ… {1:1, 2:1, 3:1, 4:2}
console.log(szamgyakorisag([1,2,2,3,4,4])); // âœ… {1:1, 2:2, 3:1, 4:2}
console.log(szamgyakorisag([]));            // âœ… {}



ğŸ§  MagyarÃ¡zat:
ğŸ”¸ 1. typeof input === "number"

Ã­gy tudjuk meg, hogy szÃ¡mot kaptunk, vagy tÃ¶mbÃ¶t;

ha szÃ¡m â†’ stringgÃ© alakÃ­tjuk, majd .split("") karaktertÃ¶mbbÃ©, Ã©s .map(Number)-rel visszaalakÃ­tjuk szÃ¡mokkÃ¡.

ğŸ”¸ 2. Ha eleve number[], akkor egyszerÅ±en bejÃ¡rjuk Ã©s szÃ¡molunk.
ğŸ”¸ 3. (eredm[szam] || 0) + 1

ha mÃ¡r volt ilyen kulcs, nÃ¶veli 1-gyel,

ha mÃ©g nem volt, akkor 0-rÃ³l indul.



ğŸ’¡ KiegÃ©szÃ­tÃ©s (ha szeretnÃ©d extra szÃ©pen kiÃ­ratni):
const eredmeny = szamgyakorisag(12344);
console.log("SzÃ¡mgyakorisÃ¡g:");
for (const [szam, db] of Object.entries(eredmeny)) {
  console.log(`${szam} â†’ ${db} db`);
}


ğŸ‘‰ Kimenet:

SzÃ¡mgyakorisÃ¡g:
1 â†’ 1 db
2 â†’ 1 db
3 â†’ 1 db
4 â†’ 2 db