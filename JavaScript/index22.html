<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>

        /*
            JavaScript ‚Äì 3 k√∂nnyebb feladat
            1Ô∏è‚É£ Pozit√≠v sz√°mok darabsz√°ma
            Tipp: filter() + .length vagy sima for ciklus.
            Ami visszaadja, h√°ny pozit√≠v sz√°m (> 0) van a t√∂mbben.

        */

           // √çrj f√ºggv√©nyt:

            function pozitivDarab(tomb) {
            // ide √≠rd a megold√°st
                return tomb.filter((szam)=>szam >0).length;
            }

            //P√©ld√°k:

            console.log(pozitivDarab([1, -2, 3, 0, 5])); // ‚Üí 3
            console.log(pozitivDarab([-1, -2, 0]));      // ‚Üí 0
            console.log(pozitivDarab([]));               // ‚Üí 0


            

        /*

            2Ô∏è‚É£ Szavak kis/nagybet≈± normaliz√°l√°sa


            
            Ami egy szavakat tartalmaz√≥ t√∂mbb≈ël √∫j t√∂mb√∂t ad vissza, ahol:

            minden sz√≥ kisbet≈±s, kiv√©ve az els≈ë bet≈±t, ami nagybet≈±s
            (pl. ‚ÄûaLma‚Äù ‚Üí ‚ÄûAlma‚Äù).
            Tipp: toLowerCase(), szo[0].toUpperCase() + szo.slice(1).

            √çrj f√ºggv√©nyt:
        */

            function normalizaltSzavak(szavak) {
            // ide √≠rd a megold√°st
                const szavakegyenk√©nt=szavak.map((szo)=>szo.toLowerCase());
              
                return szavakegyenk√©nt.map((szo) => szo[0].toUpperCase() + szo.slice(1));

                /* vagy:
                    const szavakegyenk√©nt=szavak.map((szo)=>szo.toLowerCase());
                    return szavakegyenk√©nt.map(szo => szo.length === 0 ? "" : szo[0].toUpperCase() + szo.slice(1));
                   
                  
                
                */
            }

            //P√©ld√°k:

            console.log(normalizaltSzavak(["aLma", "BAN√ÅN", "k√ñrTe"]));
            // ‚Üí ["Alma", "Ban√°n", "K√∂rte"]

            console.log(normalizaltSzavak([])); // ‚Üí []


       

        /*

            3Ô∏è‚É£ Csak stringek kiv√°logat√°sa

            //Tipp: typeof elem === "string" + filter().
            //Ami egy heterog√©n t√∂mbb≈ël csak a string t√≠pus√∫ elemeket adja vissza.
            √çrj f√ºggv√©nyt:
        */

            function csakStringek(tomb2) {
            // ide √≠rd a megold√°st
                const string=tomb2.filter((elem)=>typeof elem==='string');
                return string;
              
            }
            
            //P√©ld√°k:

            console.log(csakStringek([1, "alma", true, "k√∂rte", null]));
            // ‚Üí ["alma", "k√∂rte"]

            console.log(csakStringek([1, 2, false])); // ‚Üí []


       

          /*  üß† JavaScript ‚Äì 2 nehezebb feladat
            4Ô∏è‚É£ Sz√°mok csoportos√≠t√°sa p√°ros/p√°ratlan szerint


            Ami egy objektummal t√©r vissza:
            //Tipp: filter()-rel is megoldhat√≥, vagy for...of √©s k√©t k√ºl√∂n t√∂mb.

            {
                paros: [...],
                paratlan: [...]
            }



            √çrj f√ºggv√©nyt:
        */

            function csoportositParosParatlan(tomb3) {
                // ide √≠rd a megold√°st
                const paros=tomb3.filter((szam)=>szam % 2===0);
                const paratlan=tomb3.filter((szam)=>szam % 2!==0);
                return {
                    paros,
                    paratlan
                }
            }
            //P√©ld√°k:

            console.log(csoportositParosParatlan([1,2,3,4,5,6]));
            // ‚Üí { paros:[2,4,6], paratlan:[1,3,5] }

            console.log(csoportositParosParatlan([]));
            // ‚Üí { paros:[], paratlan:[] }


           
           /* 

            5Ô∏è‚É£ Stringek hossza ‚Äì statisztika

            √çrj f√ºggv√©nyt:


            Ami visszaad egy objektumot:

            {
            min: number | null,   // legr√∂videbb sz√≥ hossza
            max: number | null,   // leghosszabb sz√≥ hossza
            atlag: number         // √°tlagos hossz (ha √ºres ‚Üí 0)
            }           


            Tipp:

            el≈ësz√∂r alak√≠tsd √°t a szavakat hosszt√∂mbb√©: map(szo => szo.length)

            azt√°n Math.min, Math.max, reduce az √°tlaghoz.

            √úres t√∂mbn√©l k√ºl√∂n kezeld!
           
        
        */

           function hosszStatisztika(szavak2) {
                // ide √≠rd a megold√°st
                const hosszusaguk=szavak2.map((szo)=>szo.length);
                // 1) √úres t√∂mb kezel√©se EL≈êSZ√ñR
                if(hosszusaguk.length===0 )return{min:null,max:null,atlag:0};

                // 2) Csak itt sz√°molunk min/max/√°tlagot
                const min=Math.min(...hosszusaguk);
                const max=Math.max(...hosszusaguk);
                const atlag=hosszusaguk.reduce((acc,curr)=>acc+curr,0)/hosszusaguk.length;
           
               return {
                    min:min ,
                    max:max ,
                    atlag:atlag
               }
            }

           // P√©ld√°k:

            console.log(hosszStatisztika(["alma", "ban√°n", "k√∂rte"]));
            // pl. ‚Üí { min:4, max:5, atlag:4.67 }

            console.log(hosszStatisztika([]));
            // ‚Üí { min:null, max:null, atlag:0 }


            










    </script>
    
</body>
</html>