<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /* 
            ðŸŸ¨ 4 JavaScript feladat
            âœ… 1) SzÃ¡mok Ã¶sszege â€“ csak pozitÃ­v Ã©s pÃ¡ros szÃ¡mok (kÃ¶nnyebb)

            Ãrj fÃ¼ggvÃ©nyt, amely:

            egy szÃ¡mtÃ¶mbbÅ‘l

            csak a pozitÃ­v Ã‰S pÃ¡ros szÃ¡mokat adja Ã¶ssze!

            nincs talÃ¡lat â†’ tÃ©rjen vissza 0-val.

            PÃ©lda:

            pozitivParosOsszeg([1, 2, -4, 6, -3]) â†’ 8
            pozitivParosOsszeg([-2, -4]) â†’ 0

        */

        function pozitivParosOsszeg(tomb){

            const pozitvparos= tomb.filter((szam)=>szam %2===0 && szam >0);
            if(pozitvparos.length===0)return 0;
            return pozitvparos.reduce((acc,curr)=>acc+curr,0);

        }

        console.log(pozitivParosOsszeg([1, 2, -4, 6, -3]));
        console.log( pozitivParosOsszeg([-2, -4]));
       /*

            âœ… 2) SzÃ¶vegek szÅ±rÃ©se â€“ csak nagybetÅ±vel kezdÅ‘dÅ‘k (kÃ¶nnyebb)

         Ãrj fÃ¼ggvÃ©nyt, ami visszaadja azokat a stringeket a tÃ¶mbbÅ‘l,
            amelyek nagybetÅ±vel kezdÅ‘dnek.

            Figyelj: Ã¼res string ne okozzon hibÃ¡t.

            PÃ©lda:

            nagybetus(["Alma", "banÃ¡n", "Cica", "diÃ³"]) â†’ ["Alma", "Cica"]


        */

        function nagybetus(string){

            const szavak=string.map((szo)=>szo);

            const nagybetus= szavak.filter((szo)=> /^[A-Z]/.test(szo[0]));
            //Ez Ã­gy pontosabb mert az elsÅ‘ karaktert vizsgÃ¡lja
            //A test azt vizsgÃ¡lja, hogy a szo nagybetÅ±vel kezdÅ‘dik-e szo[0] Ã©rtÃ©kadÃ¡ssal
            //Ez is lehetne?Pl.:
            // szo[0] === szo[0].match(/[A-Z]/)[0]
            //Vagy :
            // szo.charAt(0) === szo.charAt(0).match(/[A-Z]/)[0]


            if(nagybetus.length===0)return [];
            return nagybetus;

        }
        console.log(nagybetus(["Alma", "banÃ¡n", "Cica", "diÃ³"]));  

        /*
         Vagy:
            function nagybetus(szavak){
                return szavak.filter(szo => szo[0] && szo[0] === szo[0].toUpperCase());
            }

            Ez azt nÃ©zi:
            â€“ van-e elsÅ‘ betÅ± (szo[0])
            â€“ Ã©s az nagybetÅ±-e.
        
        
        
        
        */




        /*
            ez nekem nehezebb volt mint a 4.feladat 
            itt kellet segÃ­tsÃ©get kÃ©rnem  :)

            ðŸ§  3) Leggyakoribb karakter egy szÃ¶vegben (kÃ¶zepes) 

            KÃ©szÃ­ts fÃ¼ggvÃ©nyt, amely:

            egy szÃ¶vegben megszÃ¡molja a karaktereket

            visszaadja azt, amelyik legtÃ¶bbszÃ¶r szerepel

            Ã¼res szÃ¶veg â†’ tÃ©rjen vissza null-lal

            PÃ©lda:

            leggyakoribbKarakter("almafa") â†’ "a"
            leggyakoribbKarakter("") â†’ null

        */

            function leggyakoribbKarakter(szoveg){
                const leggyakorbb={};

                if(szoveg.length===0)return null;

                for(const char of szoveg){
                    leggyakorbb[char]=(leggyakorbb[char] || 0)+1;
                }   
                let maxDb=0;
                let leggyakoribbChar=null;
                for(const char in leggyakorbb){
                    if(leggyakorbb[char]>maxDb){
                        maxDb=leggyakorbb[char];
                        leggyakoribbChar=char;
                    }
                }
                return leggyakoribbChar;

            }
            console.log(leggyakoribbKarakter("almafa") );//â†’ "a"
            console.log(leggyakoribbKarakter("")); //â†’ null

            //VAGY:
            function leggyakoribbKarakter2(szoveg){
                if(szoveg.length===0)return null;

                const karakterSzamlalo= szoveg.split('').reduce((acc, curr)=>{
                    acc[curr]=(acc[curr] || 0)+1;
                    return acc;
                },{});

                let maxDb=0;
                let leggyakoribbChar=null;

                for(const char in karakterSzamlalo){
                    if(karakterSzamlalo[char]>maxDb){
                        maxDb=karakterSzamlalo[char];
                        leggyakoribbChar=char;
                    }
                }
                return leggyakoribbChar;
            }
            console.log(leggyakoribbKarakter2("almafa") );//â†’ "a"
            console.log(leggyakoribbKarakter2("")); //â†’ null


        

           /* ðŸ§  4) ObjektumtÃ¶mb szÅ±rÃ©se â€“ Ã¡rsÃ¡v alapjÃ¡n (nehezebb)

            KÃ©szÃ­ts fÃ¼ggvÃ©nyt, amely egy termÃ©klistÃ¡bÃ³l visszaadja azokat a termÃ©keket, amelyek:

            Ã¡ra minAr â‰¤ Ã¡r â‰¤ maxAr

            A termÃ©kek Ã­gy nÃ©znek ki:

            { nev: string, ar: number }


            PÃ©lda:

            szuresArSzerint(
                [{nev:"Toll", ar:200}, {nev:"TÃ¡ska", ar:5000}, {nev:"FÃ¼zet", ar:1200}],
                500, 3000
            )
            // â†’ [{nev:"FÃ¼zet", ar:1200}]

         
         */

         function szuresArSzerint(termeklista,minAr,maxAr){
            const szurt= termeklista.filter((termek)=>termek.ar>=minAr && termek.ar<=maxAr);
            return szurt;



        }
        console.log(szuresArSzerint( [{nev:"Toll", ar:200}, {nev:"TÃ¡ska", ar:5000}, {nev:"FÃ¼zet", ar:1200}], 500, 3000))// â†’ [{nev:"FÃ¼zet", ar:1200}]



    </script>

   

    
</body>
</html>