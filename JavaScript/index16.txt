Mindegyik a tÃ¶mb elemcserÃ©je iâ€“j index alapjÃ¡n feladatra Ã©pÃ¼l.
2-es feladat: HibakezelÃ©s kÃ¼lÃ¶nbÃ¶zÅ‘ mÃ³dokon
A te concat-os Ã¶tleted nagyon jÃ³ volt â€” most megmutatom, hogyan Ã©rdemes profi szinten gondolkodni. ğŸŒŸ

â­ 1) Result pattern (Frontend + Backend fejlesztÅ‘k kedvence)

Nagyon tiszta, vizsgÃ¡n is tÃ¶kÃ©letes!

Itt a fÃ¼ggvÃ©ny mindig objektumot ad vissza, amiben vagy sikeres eredmÃ©ny van, vagy hiba.

function csere(tomb, i, j) {
    if (i < 0 || j < 0 || i >= tomb.length || j >= tomb.length) {
        return {
            ok: false,
            hiba: "Ã‰rvÃ©nytelen index!",
            eredeti: tomb
        };
    }

    const masolat = [...tomb];
    const temp = masolat[i];
    masolat[i] = masolat[j];
    masolat[j] = temp;

    return {
        ok: true,
        eredmeny: masolat
    };
}


ElÅ‘ny:
âœ”ï¸ tÃ­puskÃ¶vetÅ‘
âœ”ï¸ kÃ¶nnyÅ± hasznÃ¡lni
âœ”ï¸ sosem keveri a tÃ¶mbbe a hibaÃ¼zenetet

â­ 2) Optional return

Ha gond van â†’ null, ha siker â†’ Ãºj tÃ¶mb.

function csere(tomb, i, j) {
    if (i < 0 || j < 0 || i >= tomb.length || j >= tomb.length) {
        return null; 
    }

    const masolat = [...tomb];
    const tmp = masolat[i];
    masolat[i] = masolat[j];
    masolat[j] = tmp;

    return masolat;
}


ElÅ‘ny:
âœ”ï¸ nagyon rÃ¶vid
âœ”ï¸ vizsgÃ¡n elfogadjÃ¡k
âœ”ï¸ nem kever tÃ­pusokat

â­ 3) Readonly eredeti â†’ Ãºj tÃ¶mb visszaadÃ¡sa

Ezt sok tanÃ¡r szereti:

function csere(tomb, i, j) {
    if (i < 0 || j < 0 || i >= tomb.length || j >= tomb.length) {
        console.warn("HibÃ¡s index!");
        return [...tomb]; // vÃ¡ltozatlan mÃ¡solat
    }

    const ujtomb = [...tomb];
    [ujtomb[i], ujtomb[j]] = [ujtomb[j], ujtomb[i]];
    return ujtomb;
}


ElÅ‘ny:
âœ”ï¸ immutÃ¡bilis
âœ”ï¸ nem mÃ³dosÃ­tja az eredeti tÃ¶mbÃ¶t
âœ”ï¸ modern JS-es megoldÃ¡s

â­ 4) A TE Ã¶tleted: a tÃ¶mb vÃ©gÃ©re hibajelzÃ©s

Ez teljesen mÅ±kÃ¶dÅ‘kÃ©pes!
Csak Ã­gy a legszebben:

function csere(tomb, i, j) {
    if (i < 0 || j < 0 || i >= tomb.length || j >= tomb.length) {
        return [...tomb, "Nincs ilyen index!"];
    }

    const masolat = [...tomb];
    [masolat[i], masolat[j]] = [masolat[j], masolat[i]];
    return masolat;
}


ElÅ‘ny:
âœ”ï¸ kreatÃ­v
âœ”ï¸ mÅ±kÃ¶dik
âœ”ï¸ debug szempontbÃ³l nagyon jÃ³

HÃ¡trÃ¡ny:
â— a tÃ¶mb tÃ­pusÃ¡t keveri (szÃ¡m + string)

De ettÅ‘l mÃ©g NEM rossz megoldÃ¡s! ğŸ¥°