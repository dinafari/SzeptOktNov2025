a for ciklust szÃ©pen ki lehet vÃ¡ltani pl. reduce() metÃ³dussal, ha az Object.entries() tÃ¶mbjÃ©vel dolgozol.

ğŸ§© RÃ¶vid, modern megoldÃ¡s for-ciklus nÃ©lkÃ¼l:
function leggyakoribb(tomb) {
  const gyakorisag = {};

  for (const szam of tomb) {
    gyakorisag[szam] = (gyakorisag[szam] ?? 0) + 1;
  }

  const [leggyakoribbSzam] = Object.entries(gyakorisag)
    .reduce((max, akt) => (akt[1] > max[1] ? akt : max));

  return Number(leggyakoribbSzam);
}

console.log(leggyakoribb([1,2,2,3,3,3,4,4])); // â†’ 3

ğŸ’¡ MagyarÃ¡zat:

Object.entries(gyakorisag) â†’ [ ['1',1], ['2',2], ['3',3], ['4',2] ]

reduce() vÃ©gigmegy ezeken a pÃ¡rokon:

(max, akt) => (akt[1] > max[1] ? akt : max)


â€” ha az aktuÃ¡lis Ã©rtÃ©k (akt[1]) nagyobb, mint a korÃ¡bbi maximum,
akkor lecserÃ©li a maximumot.

A vÃ©gÃ©n megkapod a legtÃ¶bbszÃ¶r elÅ‘fordulÃ³ [kulcs, Ã©rtÃ©k] pÃ¡rt.

Az elsÅ‘ elem [0] â†’ maga a kulcs (a szÃ¡m string formÃ¡ban),
amit Number()-rel Ã¡talakÃ­tunk.

ğŸª„ Extra rÃ¶vid, â€egy sorosâ€ verziÃ³:

(ha mÃ¡r profi TypeScript/Javascript stÃ­lusban akarod lÃ¡tni ğŸ˜„)

const leggyakoribb = t => 
  Number(Object.entries(t.reduce((g, n) => (g[n] = (g[n] ?? 0) + 1, g), {}))
    .reduce((a, b) => b[1] > a[1] ? b : a)[0]);

console.log(leggyakoribb([1,2,2,3,3,3,4,4])); // â†’ 3


ğŸ‘‰ Ez ugyanazt csinÃ¡lja, csak minden lÃ©pÃ©st egybe fÅ±zve:
reduce a gyakorisÃ¡ghoz + Object.entries() + reduce a maximumhoz.